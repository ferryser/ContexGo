# 数据存储架构综述（2026-01-01）

本文档应当被agent跳过，除非提示词显式声明。

## 1. 文档目的
本文基于当前代码实现，总结 ContexGo 的存储现状：
- 只描述已落地实现，不作未来设计承诺。
- 说明从 UI 到 L1 传感器再到 Chronicle 落盘的完整调用链。
- 明确 Chronicle 写入、查询、落盘的路径与组织方式，为后续扩展提供基线。

## 2. 当前存储结构（Chronicle 为核心）
存储以 `data/chronicle/` 为根目录，核心数据落在 SQLite 与文件系统：

- 月度数据库：`data/chronicle/<YYYY>/<YYYYMM>.db`
  - 由 `contexgo/chronicle/assembly/chronicle_gate.py::_resolve_month_db_path` 生成。
  - 每月一个 SQLite 文件，表名固定为 `chronicle`。
- Blob 文件：`data/chronicle/<YYYY>/blobs/<MM-DD>/<object_id>.<ext>`
  - 由 `_resolve_blob_path` 生成，按“年 + 日桶”存放。
  - 扩展名由 `blob_ext/content_ext` 推断，默认 `jpg`。

> 当前实现不使用 `event/metadata/blob` 三目录，也不存在 JSONL 事件文件。

## 3. SQLite 结构与索引
`contexgo/chronicle/assembly/chronicle_gate.py` 定义了表结构与索引：

- 表结构（`chronicle`）：
  - `id`：主键（string，默认 UUIDv7）。
  - `timestamp`：浮点秒（用于时间范围查询）。
  - `source`：来源字符串（通常来自 `context_type` 或 `source`）。
  - `content`：事件内容（字符串化后的 JSON 或文本）。
  - `blob_path`：Blob 的相对路径（若无则为空）。
- 索引：`timestamp`、`source` 各自有索引，便于过滤与排序。
- SQLite 参数：`WAL` + `synchronous=NORMAL`，兼顾写入性能与安全性。

## 4. UI → Sensor → Chronicle 的真实调用链
### 4.1 UI 触发传感器生命周期
**测试 UI（Flet）** 位于 `contexgo/nexus/test_sensor/`：
- UI 入口：`contexgo/nexus/test_sensor/app.py`，调用 `ft.app(target=main)`。
- 页面逻辑：`contexgo/nexus/test_sensor/page.py`，通过 GraphQL：
  - 查询 `sensors` 列表；
  - 调用 `toggleSensor` 开关传感器；
  - 订阅 `sensorStatus` 状态更新。

### 4.2 GraphQL → 传感器管理
GraphQL 由 `contexgo/main.py::build_app()` 注册在 `/graphql`：
- Schema 定义：`contexgo/protocol/api/schema.py`。
- `toggleSensor` Mutation：
  - 通过 `get_sensor()` 取得传感器实例；
  - 调用 `sensor.start()` 或 `sensor.stop(graceful=True)`。
- `sensors` Query：
  - 通过 `list_sensors()` 获取所有已注册传感器，并读取运行状态。

### 4.3 传感器线程 → L1 事件封装
所有 L1 传感器继承 `contexgo/chronicle/base_l1_sensor.py::BaseL1Sensor`：
- 启动后由 `BaseCaptureComponent` 的线程循环触发 `_capture_impl()`。
- `_capture_impl()` 内部：
  - 采集原始 payload；
  - 生成 `object_id`（UUIDv7）；
  - 组装 L1 协议信封（`header + payload`）；
  - 写入 `RawContextProperties` 并调用 `save_raw_context(raw)`。

### 4.4 ChronicleGate 落盘
`save_raw_context()` → `save_event()` → `ChronicleGate.append()`：
- `append()` 将 payload 入队；
- `_writer_loop()` 批处理写入；
  - 默认 2 秒或 200 条触发一次写入；
  - `_prepare_record()` 规范化字段并处理 `blob_bytes/content_bytes`；
  - SQLite 记录写入月库，二进制写入 Blob 文件。

## 5. 查询路径（读接口与 GraphQL）
- `contexgo/protocol/base_chronicle.py` 定义统一读接口；
- `ChronicleGate` 实现：
  - `read_by_id`：遍历月库匹配 `id`；
  - `read_by_time_range`：按月库范围查询；
  - `read_by_source`：按 `source` 过滤。
- GraphQL Chronicle 读端：`contexgo/chronicle/graphql/schema.py`。

## 6. L2/L3 的现状与位置
- L2/L3 数据结构在 `contexgo/protocol/context.py` 中已定义：
  - `ExtractedData`、`ProcessedContext`、`Vectorize` 等。
- 目前没有单独的 L2/L3 Gate 或独立落盘实现。
- ChronicleGate 仍是唯一落盘通道，主要承载 L1 归档与基础查询。

## 7. 已知事实与注意点
- Chronicle 数据并非 JSONL 文件，而是 SQLite 表记录。
- `content` 字段为字符串化后的内容，不区分 JSON/文本。
- `blob_path` 为相对路径，指向 `data/chronicle` 内部。
- `save_event` 在异步环境下是“尽力写入”的后台任务，调用方不等待落盘。

## 8. 小结
当前系统以 ChronicleGate 为中心：
- 月度 SQLite 负责事件索引与查询；
- Blob 文件用于存放二进制数据；
- UI 通过 GraphQL 控制传感器生命周期；
- L1 传感器直接写入 ChronicleGate，L2/L3 仅在模型层存在。
