⚠️ **Human Only / 请 Codex 等 agent 跳过此文档**：此文档仅供人类阅读与评审，请不要用于自动改写或生成代码。

# L1 设计架构综述（含基类说明与 L2/L3 展望）

## 1. L1 现有设计架构概览

L1 的核心目标是**采集并封装物理信号**，形成统一的协议“信封”（Event Envelope），以便后续聚合、同步与语义计算。现有架构以三层结构串联：

1. **感知层（Chronicle / Sensors）**
   - 负责直接与系统/硬件交互，采集原始信号。
   - 典型实现为 `chronicle/sensors/window_focus.py`（窗口聚焦传感器）。
2. **基础抽象层（Base Classes）**
   - 以统一生命周期、配置校验、采集循环为规范，保证所有传感器实现风格一致。
3. **协议与注册层（Protocol / Registry）**
   - 以 `protocol/context.py` 中的 Pydantic 数据模型描述 L1 物理集装箱与后续语义结构；
   - 以 `protocol/api/sensor_registry.py` 完成传感器的创建、注册与统一访问。

这一层级设计在“采集逻辑”与“协议封装”之间划分清晰边界，有利于后续 L2/L3 的语义计算与跨设备同步。

---

## 2. 所有基类/基接口说明

> 说明：这里的“基类”指系统内部定义、供子类继承的抽象基类或核心基类。

### 2.1 `ICaptureComponent`（接口基类）
- **位置**：`protocol/capture_interface.py`
- **角色**：抽象定义感知组件的标准生命周期接口。
- **关键职责**：
  - 生命周期：`initialize` / `start` / `stop` / `is_running`
  - 数据采集：`capture`
  - 配置与状态：`get_config_schema` / `validate_config` / `get_status` / `get_statistics` / `reset_statistics`
  - 回调机制：`set_callback`
- **意义**：保证所有捕获组件具备一致的能力签名，便于统一管理和替换。

### 2.2 `BaseCaptureComponent`（感知组件基类）
- **位置**：`chronicle/base.py`
- **角色**：`ICaptureComponent` 的默认实现，封装通用生命周期、线程与统计逻辑。
- **关键职责**：
  - 线程化捕获循环（`_capture_loop`）与采样间隔控制；
  - 自动统计（捕获次数、错误次数、最后错误时间等）；
  - 默认配置校验与可扩展配置 schema；
  - 提供 `_initialize_impl` / `_start_impl` / `_stop_impl` / `_capture_impl` 等抽象钩子，留给子类实现。
- **意义**：避免传感器重复实现生命周期样板代码，确保采集行为一致。

### 2.3 `BaseL1Sensor`（L1 协议感知器基类）
- **位置**：`chronicle/base_l1_sensor.py`
- **角色**：在 `BaseCaptureComponent` 上进一步固化 L1 协议逻辑。
- **关键职责**：
  - 绑定 L1 `ContextType` 与 `ContentFormat`，确保事件类型与内容格式一致；
  - 自动生成或注入 `device_id`，保证跨设备唯一性；
  - 将原始采集 payload 封装为 L1 “信封”并输出为 `RawContextProperties`；
  - 提供 `_init_sensor` / `_collect_l1_payloads` 抽象方法，要求子类实现具体采集逻辑。
- **意义**：将“协议规范”下沉到基类层，保证 L1 事件统一、避免各传感器输出格式漂移。

---

## 3. 一致性检查：infra / utils 复用与规范性

### 3.1 infra 的复用现状
- **日志体系统一**：
  - `infra/logger.py` 与 `infra/logging_utils.py` 提供统一日志底座；
  - `chronicle/base.py`、`chronicle/base_l1_sensor.py`、`chronicle/sensors/window_focus.py` 均通过 `get_logger` 复用日志能力。
- **运行环境配置**：
  - `infra/config.py` 中 `get_sys_type` / `is_test_mode` 被 `window_focus` 复用，用于系统类型判断与测试开关。

**结论**：基础设施层复用一致性良好，日志与系统配置已经被所有核心感知组件采用。

### 3.2 utils 的复用现状
- 当前 `utils/` 仅包含空的 `__init__.py`，无可复用工具模块。

**结论**：utils 尚未承担“跨模块复用”的职责，存在以下风险：
- 未来新增功能可能在不同模块重复实现“相同工具函数”；
- infra 中的通用逻辑（如路径处理、时间格式化）若持续扩展，可能与 utils 职责重叠，造成边界不清。

### 3.3 建议的规范方向
- 将 infra 继续限定为“系统级依赖与基础设施”（日志、配置、存储通道）。
- utils 预留为“与业务逻辑无关的通用工具函数”，确保横向复用集中在 utils。
- 在新增模块时，优先复用 infra/utils 中的现有能力，避免“同名不同实现”的重复。

---

## 4. L2 / L3 扩展展望

### 4.1 从 L1 到 L2（语义抽取层）
- L1 已输出结构化的 `RawContextProperties`，具备：
  - 唯一 object_id
  - 统一 content_format
  - 物理时间戳与设备信息
- L2 可以基于 `protocol/context.py` 的 `ExtractedData` / `ProcessedContext` 进行：
  - **语义抽取**（摘要、关键词、实体识别）
  - **向量化**（`Vectorize`）
  - **多源融合**（同一时间窗口内多 L1 事件聚合）

**扩展点**：在 L2 层引入“聚合器/解析器”模块，专职把 `RawContextProperties` 转换成 `ProcessedContext`。

### 4.2 从 L2 到 L3（知识与记忆层）
- L3 可以依赖 `ProfileContextMetadata` 与 `KnowledgeContextMetadata`：
  - 形成用户画像、知识库索引与长时记忆；
  - 通过跨时间窗口的聚合与关联，形成“可检索知识图谱”。

**扩展点**：建立 L3 的“记忆索引器/推理器”，利用 L2 输出的语义结构进行多跳融合。

---

## 5. 结论

- L1 的现有架构已经完成“采集—封装—注册”的骨架设计；
- 基类体系（`ICaptureComponent` → `BaseCaptureComponent` → `BaseL1Sensor`）保证了接口一致性与协议统一性；
- infra 复用较好，但 utils 目前为空，应在后续扩展中明确其职责边界；
- L2/L3 的扩展空间清晰：语义抽取 → 语义融合 → 知识记忆。

此文档建议与现有 `docs/L1设计文档.md` 并行使用：前者强调“协议细节”，此文档强调“架构综述与演进路径”。
