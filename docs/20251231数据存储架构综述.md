# 数据存储架构综述（2025-12-31）

## 1. 文档目的
本文基于当前代码实现，重述 ContexGo 的存储现状：
- 只描述已落地实现，不作未来设计承诺。
- 说明 Chronicle 写入、查询、落盘的真实路径与组织方式。
- 明确 L1 采集与存储层的实际耦合点，为后续扩展提供基线。

## 2. 当前存储结构（以 Chronicle 为核心）
存储以 `data/chronicle/` 为根目录，核心数据落在 SQLite 与文件系统：

- 月度数据库：`data/chronicle/<YYYY>/<YYYYMM>.db`
  - 由 `_resolve_month_db_path` 生成。
  - 每月一个 SQLite 文件，表名固定为 `chronicle`。
- Blob 文件：`data/chronicle/<YYYY>/blobs/<MM-DD>/<object_id>.<ext>`
  - 由 `_resolve_blob_path` 生成，按“年 + 日桶”存放。
  - 扩展名从 `blob_ext/content_ext` 推断，默认 `jpg`。

> 当前实现不再使用 `event/metadata/blob` 三目录，也不存在 JSONL 事件文件。

## 3. SQLite 结构与索引
`contexgo/chronicle/assembly/chronicle_gate.py` 定义了表结构与索引：

- 表结构（`chronicle`）：
  - `id`：主键（string，默认 UUIDv7）。
  - `timestamp`：浮点秒（用于时间范围查询）。
  - `source`：来源字符串（通常来自 `context_type` 或 `source`）。
  - `content`：事件内容（字符串化后的 JSON 或文本）。
  - `blob_path`：Blob 的相对路径（若无则为空）。
- 索引：`timestamp`、`source` 各自有索引，便于过滤与排序。
- SQLite 参数：`WAL` + `synchronous=NORMAL`，兼顾写入性能与安全性。

## 4. 写入路径（ChronicleGate）
核心写入实现：`contexgo/chronicle/assembly/chronicle_gate.py::ChronicleGate`

### 4.1 输入入口
- `save_event(event)`：接收 dict，交给 ChronicleGate 写入。
  - 若当前有事件循环：通过 `loop.create_task` 异步写入。
  - 若无事件循环：`asyncio.run` 同步执行一次写入。
- `save_raw_context(raw)`：将 `RawContextProperties` 序列化为 dict：
  - `source` 默认回填 `context_type`（若未显式给出）。
  - `timestamp` 默认使用 `create_time`。

### 4.2 批量与异步写入
- ChronicleGate 内部维护 `asyncio.Queue`。
- `append/append_many` 只负责入队，实际落盘在 `_writer_loop` 中批处理。
- 批量写入由两条件触发：
  - 时间阈值（默认 2 秒，范围 1~5 秒）。
  - 数量阈值（默认 200 条）。

### 4.3 记录准备与落盘
- `_prepare_record` 规范化字段：
  - `id`：若缺失则生成 UUIDv7（`_uuid7()`）。
  - `timestamp`：由 `_normalize_timestamp` 统一转换为秒级浮点。
  - `source`：优先 `source`，否则 `context_type`。
  - `content`：优先 `content`，否则 `content_text`，序列化为字符串。
- 若 payload 包含 `blob_bytes/content_bytes`：
  - 写入 Blob 文件并将相对路径回填到 `blob_path`。
- 最终写入 `chronicle` 表，按月份分库。

## 5. 查询路径（读接口与 GraphQL）
- BaseChronicle 提供统一的 `read_by_id/read_by_time_range/read_by_source` 接口。
- ChronicleGate 在同步线程中执行 SQLite 查询并返回 payload：
  - `read_by_id` 会遍历当前所有月库，匹配 `id`。
  - `read_by_time_range` 根据起止时间枚举月库，再按时间范围查询。
  - `read_by_source` 在各月库内按 `source` 过滤。
- GraphQL 层：`contexgo/chronicle/graphql/schema.py`
  - 直接调用 ChronicleGate 作为唯一数据源。
  - 输出字段仅包含：`id/timestamp/source/content/blob_path`。

## 6. L1 采集与写入的真实耦合
### 6.1 L1 输出格式
- L1 传感器基类：`contexgo/chronicle/base_l1_sensor.py::BaseL1Sensor`
- 输出模型：`contexgo/protocol/context.py::RawContextProperties`
- 关键字段：
  - `object_id`：UUIDv7（事件内外一致）。
  - `content_text`：L1 事件 JSON 字符串，内含 `header + payload`。
  - `create_time`：用于 `timestamp` 归一化。

### 6.2 实际调用链
- 传感器在 `_capture_impl()` 中构造 `RawContextProperties`。
- 例如 `WindowFocusSensor` 在捕获后直接调用 `save_raw_context(raw)`。
- 当前并不存在独立的存储服务层，L1 直接写 ChronicleGate。

## 7. L2/L3 的现状与位置
- L2/L3 数据结构在 `contexgo/protocol/context.py` 中已定义：
  - `ExtractedData`、`ProcessedContext`、`Vectorize` 等。
- 但目前没有单独的 L2/L3 Gate 或独立落盘实现。
- ChronicleGate 仍是唯一落盘通道，主要承载 L1 归档与基础查询。

## 8. 已知事实与注意点
- Chronicle 数据并非 JSONL 文件，而是 SQLite 表记录。
- `content` 字段是字符串化后的内容，不区分 JSON/文本。
- `blob_path` 为相对路径，指向 `data/chronicle` 内部。
- `save_event` 在异步环境下是“尽力写入”的后台任务，调用方不等待落盘。

## 9. 小结
当前系统以 ChronicleGate 为中心：
- 月度 SQLite 负责事件索引与查询。
- Blob 文件用于存放二进制数据。
- L1 传感器直接写入 ChronicleGate，L2/L3 仅在模型层存在。

本文档旨在准确反映当下实现，为后续演进提供真实基线。
