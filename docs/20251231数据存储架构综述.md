> ⚠️ Human Only / 仅限人工阅读：此文档仅用于帮助理解现有架构。

# 数据存储架构综述（2025-12-31）

## 1. 文档目的
本文面向人类读者，聚焦“现状描述”，用于快速建立对当前存储体系的认知：
- 解释 ChronicleGate 的实际落盘形态与写入路径。
- 对齐 L1 采集链路与存储接口之间的耦合点。
- 标注 L2/L3 的扩展位置（基于已有结构与代码现状）。

## 2. 现有存储结构（基于 SQLite + 文件系统）
当前 Chronicle 的落盘形态已从纯目录文件转为**SQLite 分库 + blob 目录**：

- 根目录：`data/chronicle/`
- SQLite 数据库按月分桶：`data/chronicle/<YYYY>/<YYYYMM>.db`
- Blob 目录：`data/chronicle/<YYYY>/blobs/<MM-DD>/<object_id>.<ext>`

分桶逻辑：
- 月度 DB 由 `_resolve_month_db_path()` 决定。
- Blob 路径由 `_resolve_blob_path()` 决定，并按 “年/日桶” 分层。

## 3. ChronicleGate（当前唯一落盘实现）
核心实现位于 `contexgo/chronicle/assembly/chronicle_gate.py`：

### 3.1 写入流程
- `save_event()` 通过默认 `ChronicleGate` 异步追加记录（内部走队列）。
- `save_raw_context()` 将 `RawContextProperties` 转为字典，并补齐：
  - `source` 默认取 `context_type`（若未显式提供）
  - `timestamp` 默认取 `create_time`
- 实际写入发生在 `_writer_loop()`，批量落入 SQLite。

### 3.2 数据表结构
SQLite 表名固定为 `chronicle`，字段如下：
- `id`（主键）
- `timestamp`（时间戳）
- `source`（来源/类型）
- `content`（文本或 JSON 字符串）
- `blob_path`（可选，指向 blobs 目录的相对路径）

### 3.3 记录封装逻辑
在 `_prepare_record()` 中执行：
- `id` 优先使用 payload 的 `id/object_id`，否则生成 UUIDv7。
- `timestamp` 统一归一化（支持数字/ISO 时间/字符串）。
- `content` 优先使用 `content`，否则使用 `content_text`。
- 若 payload 包含 `blob_bytes/content_bytes`，写入 blob 并记录 `blob_path`。

## 4. 抽象接口与继承关系
### 4.1 BaseChronicle
- 位置：`contexgo/protocol/base_chronicle.py`
- 定义 CRUD 接口与 GraphQL Resolver 入口。
- 关键方法：`create/read_by_id/read_by_time_range/read_by_type/update/delete`。

### 4.2 ChronicleGate
- 位置：`contexgo/chronicle/assembly/chronicle_gate.py`
- 角色：BaseChronicle 的当前唯一实现。
- 特性：
  - 异步 `_queue` + `_writer_task` 进行批量落盘。
  - 按月分库写入 SQLite。
  - Blob 独立写入文件系统，避免 JSON 膨胀。

## 5. L1 采集层与存储边界（现状）
### 5.1 L1 输出结构
- L1 传感器基类：`contexgo/chronicle/base_l1_sensor.py`
- 输出模型：`contexgo/protocol/context.py::RawContextProperties`

当前 L1 输出的核心特征：
- `object_id` 由 BaseL1Sensor 生成 UUIDv7，内外一致。
- `content_text` 为 JSON 字符串，封装 header + payload。
- `create_time` 作为物理时间锚点。
- `source` 来自传感器的 ContextSource。

### 5.2 现有耦合方式
- `WindowFocusSensor` 直接调用 `save_raw_context()` 写入。
- `save_raw_context()` 将 `RawContextProperties` 转为通用 payload，再进入 ChronicleGate 队列。

结论：L1 与 ChronicleGate 仍为“直连式耦合”，未形成独立存储服务层。

## 6. L2/L3 的扩展理解（基于当前结构）
### 6.1 L2（语义层）
`contexgo/protocol/context.py` 已包含：
- `ExtractedData`
- `ProcessedContext`

潜在扩展方式包括：
- 引入新的 Gate 子类（语义专用 Gate）。
- ChronicleGate 内通过 `source/context_type` 做分区写入。
- 引入向量/实体索引与 L2 数据并行。

### 6.2 L3（认知层）
L3 通常聚合为更高语义对象（任务、意图、叙事）：
- 可新增专用目录或独立存储系统（图数据库/向量数据库）。
- ChronicleGate 保持 L1/L2 可追溯归档，L3 存储聚合结果。

## 7. 一致性与注意点
### 7.1 字段一致性
- `object_id`：由 L1 统一生成并贯穿写入流程。
- `create_time`：用于时间归一化与分桶。
- `source/context_type`：写入时 source 若缺省会回退到 context_type。

### 7.2 存储形态
- 事件数据当前统一进入 SQLite 的 `chronicle` 表，而非文件级 JSONL。
- 大对象仍以文件系统写入，并在表中记录相对路径。

### 7.3 API 一致性
GraphQL 目前仍以 ChronicleGate 为单一数据源。若后续新增 Gate，需要在 API 层显式区分入口。

## 8. 小结
当前架构已转为“SQLite 分库 + Blob 文件系统”的混合落盘模式，并通过 ChronicleGate 异步批量写入。本文档旨在帮助理解现有实现，以便对 L2/L3 的扩展与边界演进做出正确判断。
